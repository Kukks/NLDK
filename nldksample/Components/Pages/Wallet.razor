@page "/wallets/{walletId}"
@using NLDK
@using Newtonsoft.Json
@using Script = NBitcoin.Script
@using NBitcoin
@using NBXplorer
@using nldksample.LDK
@using org.ldk.structs
@using Coin = NLDK.Coin
@using TxOut = NBitcoin.TxOut
@inject WalletService WalletService
@inject Network Network
@inject ExplorerClient ExplorerClient
@inject LDKNodeManager NodeManager
<PageTitle>Home</PageTitle>
@if (WalletData is null)
{
    <p>loading</p>
}
else
{
    <h3>Wallet @WalletData.Name</h3>
    <span>Total balance: @Balance</span>
    <ul>
        @foreach (var s in WalletData.Scripts)
        {
            var totalReceived = s.Script.Coins.Sum(coin => coin.Value);
            var totalSpent = s.Script.Coins.Where(coin => coin.SpendingTransactionHash is not null).Sum(coin => coin.Value);
            <li>
                <input type="text" readonly="readonly" value="@Script.FromHex(s.ScriptId).GetDestinationAddress(Network)"/>
                @if (s.DerivationPath is null)
                {
                    <span>UNSPENDABLE!</span>
                }
                @s.Script.Coins.Count coins, balance:@(totalReceived - totalSpent) , total rec: @totalReceived, total sent: @totalSpent
            </li>
        }
    </ul>
    <button class="btn-primary" @onclick="Derive">Derive new address</button>

    <h4 class="mt-4">Send</h4>
    <input type="number" @bind="SendValue" step="any" min="0.0000001" max="@Balance" placeholder="send amt"/>
    <input type="text" @bind="SendDest"/>
    <button @onclick="Send">Send</button>

    @if (_node is not null)
    {
        var peerHandler = _node.ServiceProvider.GetService<LDKPeerHandler>();
        var peers = peerHandler.GetPeerNodeIds().ToList();
        var channelManager = _node.ServiceProvider.GetService<ChannelManager>();
        var channels = channelManager.list_channels();

        <h4 class="mt-4">Node Info</h4>
        if (_node.NodeInfo is not null)
        {
            <div>Node URI: @_node.NodeInfo.ToString()</div>
        }
        else
        {
            <div>Pubkey: @_node.NodeId.ToString()</div>
        }

        <h4 class="mt-4">Peers</h4>
        @if (peers.Any())
        {
            <ul>
                @foreach (var peer in peers)
                {
                    <li>
                        @peer
                    </li>
                }
            </ul>
        }
        else
        {
            <p>No peers yet</p>
        }
        <input type="text" @bind="ConnectPeer"/>
        <button @onclick="ConnectToPeer">Connect to peer</button>

        <h4 class="mt-4">Channels</h4>
        @if (channels.Any())
        {
            <ul>
                @foreach (var channel in channels)
                {
                    var id = channel.get_channel_id();
                    <li>
                        @Convert.ToHexString(id)
                        <br/>
                        usable: @channel.get_is_usable()
                        <button @onclick="() => CloseChannel(channel, false)">Close </button>
                        <button @onclick="() => CloseChannel(channel, true)">Force Close </button>
                    </li>
                }
            </ul>
        }
        else
        {
            <p>No channels yet</p>
        }
    }

    <h4 class="mt-4">Raw wallet data</h4>
    <pre>@JsonConvert.SerializeObject(WalletData, Formatting.Indented, new JsonSerializerSettings { ReferenceLoopHandling = ReferenceLoopHandling.Ignore })</pre>
}

@code {
    private LDKNode? _node;

    private decimal Balance
    {
        get { return UnspentCoins?.Sum(coin => coin.Value) ?? 0; }
    }

    private IEnumerable<Coin>? UnspentCoins => WalletData?.Scripts.Where(walletScript => walletScript.DerivationPath is not null).SelectMany(script => script.Script.Coins).Where(coin => coin.SpendingTransactionHash is null);

    [Parameter] public string WalletId { get; set; }
    private NLDK.Wallet? WalletData { get; set; }

    protected override Task OnParametersSetAsync()
    {
        _ = Fetch();
        return base.OnParametersSetAsync();
    }

    private async Task Fetch()
    {
        await WalletService.Get(WalletId).ContinueWith(async task =>
        {
            WalletData = task.Result;
            _node = await NodeManager.GetLDKNodeForWallet(WalletData);
            await InvokeAsync(StateHasChanged);
        });
    }

    private async Task Derive()
    {
        await WalletService.DeriveScript(WalletId);
        await Fetch();
    }

    private decimal SendValue { get; set; }
    private string? SendDest { get; set; }
    private string? ConnectPeer { get; set; }

    private async Task Send()
    {
        if (string.IsNullOrEmpty(SendDest))
        {
            return;
        }

        SendDest = SendDest.Trim();
        var addr = BitcoinAddress.Create(SendDest, ExplorerClient.Network.NBitcoinNetwork);
        var feeRate = await ExplorerClient.GetFeeRateAsync(1, new FeeRate(100m));

        var tx = await WalletService.CreateTransaction(WalletId, new List<TxOut>()
        {
            new TxOut(Money.Coins(SendValue), addr.ScriptPubKey)
        }, feeRate.FeeRate);
        await ExplorerClient.BroadcastAsync(tx.Value.Tx);
    }

    private async Task ConnectToPeer()
    {
        if (_node == null || string.IsNullOrEmpty(ConnectPeer))
        {
            return;
        }

        if (!BTCPayServer.Lightning.NodeInfo.TryParse(ConnectPeer, out var nodeInfo))
        {
            return;
        }

        var peerHandler = _node.ServiceProvider.GetService<LDKPeerHandler>();
        _ = await peerHandler.ConnectAsync(nodeInfo, CancellationToken.None);
    }

    private Task CloseChannel(ChannelDetails channel, bool force)
    {
        var channelManager = _node.ServiceProvider.GetRequiredService<ChannelManager>();
        var result = force ? channelManager.force_close_broadcasting_latest_txn(channel.get_channel_id(), channel.get_counterparty().get_node_id()) : channelManager.close_channel(channel.get_channel_id(), channel.get_counterparty().get_node_id();

        if (result is Result_NoneAPIErrorZ.Result_NoneAPIErrorZ_Err error)
        {
            _node.ServiceProvider.GetRequiredService<LDKWalletLogger>().Log(LogLevel.Error, $"Error{(force? " force": "")} closing channel: {error.err.GetError()} ");
        }
        return Task.CompletedTask;
        
    }

}
